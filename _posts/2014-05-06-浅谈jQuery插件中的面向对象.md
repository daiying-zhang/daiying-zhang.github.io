---
layout: default
title: 浅谈jQuery插件中的面向对象
category: article
---

在jQuery盛行的今天，各种jQuery的插件也是漫天飞舞，很多人都希望或者已经写出过很多实用的插件，这其中一些插件大部分能满足用户的需求，也有很多情况下不能满足用户更多的需求，比如我们有一个最简单的插件，用来改变一个DOM元素的部分样式也可以改变元素字体的大小，暂且命名为`$.fn.colorit`，很多人写出的插件，我们引入后就可以直接调用

    //color it
    $("#demo").colorit({color:'red','fontSize':'12px'});
    
这当然没有问题。问题是，上面的代码中返回的对象，没有提供给我们更多的方法去调用，比如我想直接设置字体大小，要是能以某种方式返回一个方法，我可以直接调用，比如

    XXX.setFontSize('23px');

这样的需求其实还是比较多的，尤其是在一些与UI有关的插件里面。比如我们有一个滚动条，有时候我们需要直接设置它滚动的距离，我们也可能需要在内容更改后改变滚动条的长度，如果不提供可以访问的方法，要操作起来肯定会比较麻烦的。如果用面向对象的思想去实现，可以更轻松的返回一些方法，是程序更加强大更灵活。

还有一点就是，随着需求的改变，很多时候我们可能需要改变某一个功能，或者要增加一个功能，如果以普通的面向过程的方式去写插件，要修改增加功能也会比较麻烦，数据访问是一个问题，维护困难是另一个问题。

所以，用面向对象的方法去写插件，优势应该是相当明显的。

## 简单实现

下面就以上面提到的简单的`colorit`插件为例，简单的实现。

    ;(function($){
          $.fn.colorit = function(settings){

              var defaults = {
                          "color":'red',
                          'font-family':'Microsoft YaHei',
                          'font-size':'15px'
                      },
                  opts = $.extend(defaults,settings);

              return this.each(function(){
                  var $this = $(this),
                      color = opts.color,
                      fontFamily = opts['font-family'],
                      fontSize = opts['font-size'];

                  var render = function(){
                      $this.css({
                          "color":color,
                          'font-family':fontFamily,
                          'font-size':fontSize
                      });
                  }
                  render();
              });
          }
      })(jQuery);

      $(function(){
          $('#test,#test1').colorit({color:'blue','font-family':'Consolas','font-size':'20px'});
      });
        
这样的确简单的实现了我们的需要，改变了文字字体、大小、颜色。但是如果我们想过2s后文字变成红色，对于这个简单的例子，我们可以这样写：

    setTimeout(function(){
        $('#test,#test1').colorit({color:red,'font-family':'Consolas','font-size':'20px'});
    },2000)
    
## 存在的问题

这样的话可以实现，重新调用了一次插件，但是事实上很多插件直接重复调用是会出错的，比如一个滚动条组件，初始化一次之后，改变了DOM结构，重复调用又会改变DOM结构，肯定出错。

而且还有一个问题是：上面的例子中，如果我只想改变字体的颜色，而字体以及字体的大小还是保持第一次初始化的值，如果我单纯的值设置`color`的值，第一次渲染的字体的大小和字体都没有了。

此外，如果我们想增加一些新的功能，比如我要从外部获取当前设置的颜色等信息，是无法获取的，因为插件没有提供给我们这个功能，我们只能自己想办法去获取。如果我们向上面这样写插件，要增加这个功能，就比较费劲了。所以维护比较困难。

## 面向对象

下面我们简单的用面向对象的方式来实现这个插件，并提供外部接口。
    
    ;(function($){
          /**
           * @name $.fn.colorit
           * @constructor
           * @param {Object} [settings] 配置参数
           * @param {String} [settings.color='red'] 字体颜色
           * @param {String} [settings.font-family='Microsoft YaHei'] 字体
           * @param {String} [settings.font-size='15px'] 字体大小
           * @returns {*}
           */
          $.fn.colorit = function(settings){
              var defaults = {
                          "color":'red',
                          'font-family':'Microsoft YaHei',
                          'font-size':'15px'
                      },
                  opt = $.extend(defaults,settings);

              return this.each(function(){
                  var ci = new ColorIt($(this),opt); //实例化
                  ci.render(); //渲染元素
              });
          }

          /**
           * 构造函数
           * @param obj
           * @param settings
           * @constructor
           */
          function ColorIt(obj,settings){
              this._obj = obj;
              this._color = settings.color;
              this._fontSize = settings['font-size'];
              this._fontFamily = settings['font-family'];
          }

          /**
           * 渲染元素
           * @name render
           * @constructor
           * @return {ColorIt}
           */
          ColorIt.prototype.render = function(){
              this._obj.css({
                  "color":this._color,
                  'font-family':this._fontFamily,
                  'font-size':this._fontSize
              });
              return this
          }

      })(jQuery);
        
上面的代码，用面向对象的思想是实现了渲染元素。我们可以这样调用

    $('#test,#test1').colorit({color:'blue','font-family':'Consolas'});

## 更丰富的接口

但是没有提供给外部任何方法。要实现这个，我们可以先将实例化的对象存储到DOM元素上面，也就是利用jquery的`data()`方法，当我们第一次调用插件并传入一些配置参数后，就可以再次调用插件，并传入一个特殊的字符串来获取相对应的实例对象，这些实例对象的方法我们就可以随意调用了。

代码如下：
    
    ;(function($){
          /**
           * @name $.fn.colorit
           * @constructor
           * @param {Object} [settings] 配置参数
           * @param {String} [settings.color='red'] 字体颜色
           * @param {String} [settings.font-family='Microsoft YaHei'] 字体
           * @param {String} [settings.font-size='15px'] 字体大小
           * @returns {*}
           */
          $.fn.colorit = function(settings){
              var defaults = {
                          "color":'red',
                          'font-family':'Microsoft YaHei',
                          'font-size':'15px'
                      },
                  opt = $.extend(defaults,settings);
              var KEY = 'jcolorit',
                  obj = this.data(KEY);
              if(typeof settings === 'string'){ //如果传入的是一个字符串
                  if(settings === 'getObject'){ //通过getObject来获取实例
                      if(obj){
                          return obj; //返回ColorIt的实例对象
                      }else{
                          throw new Error('This object is not available');
                      }
                  }
              }
              return this.each(function(){
                  var ci = new ColorIt($(this),opt); //实例化
                  ci.render(); //渲染元素
                  $(this).data(KEY,ci); //将实例化对象缓存
              });
          }

          /**
           * 构造函数
           * @param obj
           * @param settings
           * @constructor
           */
          function ColorIt(obj,settings){
              this._obj = obj;
              this._color = settings.color;
              this._fontSize = settings['font-size'];
              this._fontFamily = settings['font-family'];
          }

          /**
           * 渲染元素
           * @name render
           * @constructor
           * @return {ColorIt}
           */
          ColorIt.prototype.render = function(){
              this._obj.css({
                  "color":this._color,
                  'font-family':this._fontFamily,
                  'font-size':this._fontSize
              });
              return this
          }

         /**
           * 设置颜色
           * @name setColor
           * @constructor
           * @param color
           * @return {ColorIt}
           */
          ColorIt.prototype.setColor = function(color){
              this._color = color;
              return this
          }
      })(jQuery);
        
调用方法如下：

    $('#test,#test1').colorit({color:'blue','font-family':'Consolas'});
    
如果我们两改变#test的颜色
    
    var test = $('#test').colorit('getObject');  //返回实例
    test.setColor('green')  //调用实例的方法
        .render();  //链式调用实例的方法
        
## 链式调用    
    
上面就实现了方法的返回，用户可以单独的设置颜色然后重新渲染。上面的对象的方法返回了实例对象本身，故也可以实现类似jQuery的链式调用，但是这样违背了一个重要的原则：jQuery的链式调用，既然写的是jQuery插件，建议还是要返回jQuery对象。下面，我们在保留上述调用方式的基础上，继续用另一种方式实现调用方法后返回jQuery对象:

    (function($){
          /**
           * @name $.fn.colorit
           * @constructor
           * @param {Object} [settings] 配置参数
           * @param {String} [settings.color='red'] 字体颜色
           * @param {String} [settings.font-family='Microsoft YaHei'] 字体
           * @param {String} [settings.font-size='15px'] 字体大小
           * @returns {*}
           */
          $.fn.colorit = function(settings){
              var defaults = {
                          "color":'red',
                          'font-family':'Microsoft YaHei',
                          'font-size':'15px'
                      },
                  opt = $.extend(defaults,settings);
              var KEY = 'jcolorit',
                  obj = this.data(KEY);
              if(typeof settings === 'string'){
                  if(settings === 'getObject'){
                      if(obj){
                          return obj; //返回ColorIt的实例对象
                      }else{
                        throw new Error('This object is not available');
                      }
                  }else{
                      if(obj &amp;&amp; obj[settings]){
                          //console.log(arguments);
                          obj[settings](Array.prototype.splice.call(arguments,1));
                      }
                  }
                  return this //返回jQuery对象
              }
              return this.each(function(){
                  var ci = new ColorIt($(this),opt); //实例化
                  ci.render(); //渲染元素
                  $(this).data(KEY,ci); //将实例化对象缓存
              });
          }

          /**
           * 构造函数
           * @param obj
           * @param settings
           * @constructor
           */
          function ColorIt(obj,settings){
              this._obj = obj;
              this._color = settings.color;
              this._fontSize = settings['font-size'];
              this._fontFamily = settings['font-family'];
          }

          /**
           * 渲染元素
           * @name render
           * @constructor
           * @return {ColorIt}
           */
          ColorIt.prototype.render = function(){
              this._obj.css({
                  "color":this._color,
                  'font-family':this._fontFamily,
                  'font-size':this._fontSize
              });
              return this
          }

          /**
           * 设置颜色
           * @name setColor
           * @constructor
           * @param color
           * @return {ColorIt}
           */
          ColorIt.prototype.setColor = function(color){
              this._color = color;
              return this
          }

          /**
           * 改变字体大小
           * @name setFontSize
           * @constructor
           * @param size
           * @returns {*}
           */
          ColorIt.prototype.setFontSize = function(size){
              this._fontSize = size;
              return this;
          }
      })(jQuery);
      
下面我们可以这样调用：

    $('#test,#test1').colorit({color:'blue','font-family':'Consolas'});
    setTimeout(function(){
        //jQuery链式调用
        $('#test').colorit('setColor','red').  //调用实例化对象的方法setColor()并传入参数'red'
                  colorit('setFontSize','40px'). //调用实例化对象的方法setFontSize()并传入参数'40px'
                   colorit('render').  //调用实例的render()方法
                   css({'opacity':0.7}); //调用jQuery的方法
    },2000);
    setTimeout(function(){
        //实例提供的链式调用
        var test = $('#test').colorit('getObject'),  //返回实例
            test1 = $('#test1').colorit('getObject');
        test.setColor('green').  //调用实例的方法
             setFontSize('30px'). //链式调用实例的方法
             render();  //链式调用实例的方法
        test1.setColor('orange').
              setFontSize('50px').
              render();
    },4000);
            
上面的代码分别用两种方式调用了插件提供给用户的方法，实现的效果是：

* 页面加载的时候，两行文字都设置为蓝色、Consolas字体、默认字体大小；

* 2s后第一行文字设置为红色、40px、透明度0.7（调用jQuery方法）；

* 4s后第一行文字设置为绿色、30px，第二行文字设置为橙色、50px。

至此，我们需要的功能就实现了。下面就看需求的改变，加上我们现在需要在外部获取颜色的值，当然单纯获取颜色的值也可以用jQuery的css()方法来获取，如果是其他的功能很可能jQuery也无能为力了，那么我们给对象扩充一个方法：

    /**
     * 获取当前颜色信息
     * @name getColor
     * @constructor
     * @returns {String}
     */
    ColorIt.prototype.getColor = function(){
       return this._color;
    }
        
现在我们就可以在外部类似的调用:

    test.getColor()

[在线演示](http://jsbin.com/imufew/2/edit)

文章到这就结束了，以上的一些文字都是基于一些实践，自己的总结，观点以及代码不一定对。如果发现观点或者代码中有不对的地方，欢迎与我交流。

---
layout: default
title: JS中你可能没注意到的细节（3）
category: article
---

在 [JS中你可能没注意到的细节（2）](./JS中你可能没注意到的细节（2）.html) 中，提到了类型转换中的一些细节。今天继续说一些正则表达式中的细节:

## new RegExp()

假设现在有这样一个简单的需求,我们需要动态的匹配用户输入的单词,那么用正则表达式的话,就需要用`new RegExp()`的方式获取正则表达式对象，
而无法使用直接量的方式得到。

直接量声明方式：

    var pattern = /\bJavaScript\b/ig;//匹配模式是固定的
    new RegExp()方法中需要注意‘\'字符的使用

    var pattern = new RegExp("\bJavaScript\b","ig");//错误
    var pattern = new RegExp("\\bJavaScript\\b","ig");//正确

## 贪婪模式

如果想匹配每一个HTML标签：

    console.log(/<(\w+)>(.*)<\/\1>/.exec('<p>Hello World!</p><p>ZDY</p>'));

实施上，上面的执行结果是：

    ["<p>Hello World!</p><p>ZDY</p>", "p", "Hello World!</p><p>ZDY"]

这显然不是我们想要的结果，因为默认以贪婪模式去匹配，采用非贪婪模式如下：

    p = /<(\w+)>(.*?)<\/\1>/g;
    p.exec('<p>Hello World!</p><p>ZDY</p>'); // => ["<p>Hello World!</p>", "p", "Hello World!"]
    p.exec('<p>Hello World!</p><p>ZDY</p>'); // => ["<p>ZDY</p>", "p", "ZDY"]

但是如果我们想匹配`aaab`中的`ab`,如果使用`/a+?b/`,还是不能达到我们想要的结果，事实上`/a+?b/`匹配了整个字符串，原因：

正则表达式的模式匹配总是会寻找字符串中第一个可能匹配的位置。

## match() 与exec()

给字符串的`mathch()`方法传入的是非全局的正则表达式的话，执行结果和这个正则表达式的`exec()`方法执行结果一样:

    var s = '[01:26.05][02:50.40]已经长大的约定 那样清晰';
    var reg = /(\[\d{2}:\d{2}\.\d{2}\])/;
    reg.exec(s); // => ["[01:26.05]", "[01:26.05]"]
    s.match(reg); // => ["[01:26.05]", "[01:26.05]"]
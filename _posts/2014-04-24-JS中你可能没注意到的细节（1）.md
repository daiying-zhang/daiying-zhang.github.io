---
layout: default
title: JS中你可能没注意到的细节（1）
category: article
---

## 溢出

在JavaScript中,在进行算术运算时,如果发生溢出(*Overflow*)或者下溢(*Underflow*)或者被除零时，其实不会报错，而是返回一些特殊的值。

溢出(*Overflow*)也就是计算结果超过了JavaScript锁能表示的数字上限，结果会返回`Infinity`(无穷大)或者`-Infinity`(负无穷大)；
如果执行以下代码,结果并不会报错,而是弹出一些特殊的值:

    alert(1/0);// =>  Infinity
    alert(-1/0);// => -Infinity

## NaN

非数字值（`NaN`）比较特殊，它不跟任何值相等，包括它本身，也就是说下面的代码均返回`false`：

    alert(NaN == NaN);// => false
    alert(NaN == "abc");// => false
    alert(NaN == /abc/ig);// => false
    alert(NaN == [1,2,3]);// => false
    alert(NaN == {});// => false

那么,要怎么判断一个值是否为`NaN`呢?我们可以采用如下方法:

    var a = NaN;
    alert(a == NaN);// => false, 无法判断
    alert(a != a);// => true,结果正确（只有a为NaN时，表达式的值才为true）

此外,我们可以用`isNaN()`函数判断一个值是否为`NaN`，如果参数是`NaN`或者可以转换成`NaN`的值,返回`true`,否则返回`false`;

## 精度

    alert(0.3-0.2);// => 0.09999999999999998
    alert(0.4-0.3);// => 0.10000000000000003
    alert(0.3-0.2 == 0.4-0.3);// => false

很奇怪的是,为什么结果不是`0.1`呢?`0.3-0.2`为什么不等于`0.4-0.3`呢?

其实,在Java中计算也会出现这样的问题,任何使用二进制浮点数的编程语言都会出现这个问题.
JavaScript采用**IEEE-754浮点数表示法**，这是一种二进制表示法，可以精确的表示分数，比如1/2,1/4,1/8...但是二进制浮点数表示
法并不能精确的表示类似0.1的数值,由于舍入误差,使得`0.4`跟`0.3`的差值和`0.3`跟`0.2`之间的差值并不相等.